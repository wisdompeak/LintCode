### 965. LR String

#### Description
```
给出两个只有 'l', 'r' 的字符串 s 和 t，以及一个整数 n。
请求出能否按照以下规则，将 s 转换成 t，如果能，返回真，否则返回假。

'l' 字符只能向左移动（与它左边的字符交换位置），'r' 只能往右移（与它右边的字符交换位置）。
'l' 和 'r' 字符相互交换的最大次数为 n。

设 s 和 t 的长度为 m，1≤m≤5*10^4​​。 0≤n≤2^​31​​−1。
```
#### 分析：
```
首先明确一个概念：我们所有的有效操作必然是l和r的交换。任何l与l的交换、r与r的交换都是没有意义的。
另外，我们将l左移（与r交换）和将r右移（与l交换）本质都是一样的。
所以此题相当于问：能否通过最多n次“将l左移与r交换”来实现从s到t的变换。

我们用一个队列q来依次记录'l'所在的位置。接下来会看到有什么用处。

我们需要分析如下一些场景：(假设***部分表示已经转换成功)
1. 如果当前t[k]=='r'
s = *** ...r...
t = *** r...
这种情况下，我们必须要求s[k]=='r'！
(a) 如果s里的下一个r不在k这个位置（也就是说q的队首元素就是k），因为我们无法左移r，所以只能返回false
(b) 如果s里的下一个r就在k这个位置（也就是说q的队首元素不是k），那么s[k]==t[k]=='r'，皆大欢喜，
我们就略过k这个位置（同样可以标记为*），递归处理下一个位置。

2. 如果当前t[k]=='l'
s = *** ...l...
t = *** l...
这种情况下，我们显然会将s的下一个'l'（也就是q的队首元素）左移到第k个位置。
这个过程需要的交换次数是times = q.front()-k. 
(a) 如果times > n，那么我们就没有足够的操作机会来实现。返回false。
(b) 如果times <= n，那么我们就成功实现了s[k]==t[k]=='l'的配对。
我们就略过k这个位置（同样可以标记为*），递归处理下一个位置。
注意，递归到下一个回合之前，我们要将q的队首元素弹出（因为那个'l'已经被移走了），并且n减去这一步用掉的操作次数。

以上的场景如果能成功进行m次，就意味着依次处理完了t[k]的每一个元素，使得所有位置上s[k]==t[k]了。

所以算法的时间复杂就是o(m).
```
