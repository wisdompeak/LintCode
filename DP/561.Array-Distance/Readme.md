### 561. Array Distance

#### Description
```
定义两个等长数组的距离为它们各项相同下标的差值绝对值之和。
比如，A[]=[5,4,3,7,8],B[]=[3,4,2,1,9] ,那么A[]和B[]的距离为|5-3|+|4-4|+|3-2|+|7-1|+|8-9|=10。
在这个问题中，给出一个数组A[]，你需要找到一个等长的不递减数组B[]，使得A[]和B[]的距离值最小。
你只需返回最小的距离值。

1<=数组长度<=1000
1<=元素大小<=1000000000
```

#### 分析：
```
首先我们要证明一个很重要的性质：一定存在这样一个B，它是最优解（即最小总距离值），并且B的每个元素都是在A中出现过的。

我们先假设B是某个最优解，根据题意，它的元素一定是分段的形式 (piecewise constant)

			————————
	————————
————
我们取一段区间来分析。令B在这一段里的元素都是相同的x（元素个数可以是1个或者多个），
在这段区间前的B的元素一定比x小，在这段区间后的B的元素一定比x大。

现在我们这段区间内考虑A的元素会怎么分布？是否可以x不与任何A元素相同？
1. 如果A元素都比x大
       *
           *         
	*				———————— y
	————————   x
显然，我们继续提升x的话一定能使总距离变小，这和B是最优解相矛盾。
有人会说x不能再增大是因为不能超过后面的B元素，但是这又与“该区间后的B的元素一定比x大”相矛盾。
所以这种A的分布情况不存在。

2. 如果A元素都比x小
同理，这种情况也不存在。

3. A的元素相比于x，有的大，有的小，但是没有相同的。又分三种情况：
(a)
         * *
            *			———————— y
	—————————   x
	*
	  *		
如果比x大的元素 比 比x小的元素多，我们发现把x往大调整一定能使总距离变小，这和B是最优解相矛盾。所以这种情况不存在。

(b)
         * 
            *			———————— y
	—————————   x
	*
	  *	  *	
如果比x小的元素 比 比x大的元素多，同理可证，这种情况不存在。

(c)
         * 
            *			———————— y
	—————————   x
	*
	  *	 	
如果比x小的元素和比x大的元素一样多，那么x在相邻的两个A元素之间任意调整，都不会影响总距离。
甚至将x与某个临近的A元素重合，也不影响最优解。那么我们索性就将x搬过去。
（注意，如果x受到y的制约而不能与某个A元素重合，那么意味着将x和y平齐也是一个最优解，
但这样的话两个区间其实相接了，但我们在讨论时限定了只考虑独立的区间）

===============
综上所述：对于任何一种最优解B，x必须不能与A元素重合的情况不存在！
无论最优解B如何，要么x必然与A元素重合；要么就像 3(c)，将x移至与最邻近的A元素重合也不影响答案。

所以必然存在一个最优解B，它的元素全部来源于A，并且是递增的。即，存在最优解B是 sorted(A) 的一个递增子序列（允许重复）。

令dp[i][j]表示B[i]==A'[j]时、A的前i个元素得到的最小距离和。

B :  X X X X i
A' : Y Y Y j

突破口：如果B[i]==A'[j]，那么B'[i-1]可以等于A'[0],A'[1],...,A'[j-1],A'[j]，因为它们都不超过A'[j]。
我们要从中挑选一个最优的，即 dp[i][j] = min{dp[i-1][0], dp[i-1][1], ..., dp[i-1][j-1], dp[i-1][j]} + abs(A[i]-B[j])

for (int i=0; i<n; i++)
	minVal = MAX
	for (int j=0; j<n; j++)
		minVal = min(minVal, dp[i-1][j])
		dp[i][j] = minVal + abs(A[i]-B[j])

最终的答案应该 min{dp[n-1][j]}, for j=0, 1,...,n-1


此外，本题还有一个神奇的NlogN的解法。个人目前还无法理解。

```
