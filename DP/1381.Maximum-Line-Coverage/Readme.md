### 1381.Maximum-Line-Coverage

我们令dp[i][j]表示闭区间[1:i]内我们用了j条线段能过够最多覆盖的点数。注意，传统的DP转移方法，是通过已知的过去的DP，来确定当前的dp[i][j]。对于此题，我们采用DP的另一种不是那么常见（但也不少见）的转移方法，即我们已知当前的dp[i][j]，我们来更新某些未来的dp。为什么这么做呢？因为通过dp[i][j]我们更容易找出哪些“关键的”未来dp可以更新；而反之，我们很难穷举所有可以转移到dp[i][j]的过去的dp。

假设我们已知dp[i][j]，下一个目标点是i+1，我们有两种决策：

1. 我们不取任何经过i+1的线段，即不打算覆盖i+1，那么对于dp[i+1][j]的值就是直接继承自dp[i][j]. 但是注意，这个转移方案只是dp[i+1][j]的一种可能，所以应该写成 ```dp[i+1][j] = max(dp[i+1][j], dp[i][j])```

2. 我们取一条经过i+1的线段。假设经过i+1的线段最远可以到达far，那么我们自然会贪心地更新```dp[far][j+1] = dp[i][j]+1```. 和上面相同的原因，我们应该写成```dp[far][j+1] = max(dp[far][j+1], dp[i][j]+1)```. 有人会问，那么在i+1和far中间的任意一点t，我们为啥不同样逐一更新这些```dp[t][j+1]```呢？因为这些状态不是最优的（我们可以一鼓作气覆盖到far而不是只停留在t），根据它们所得到的其他DP也不会是最优的，所以没有必要取更新它们的状态。

OK，那么如何知道经过i+1的线段最远可以到达的far在哪里呢？我们只需要将所有线段按照起始端排序，在起点是[1:i+1]的所有线段的终点中挑选rolling max即可。

只要我们在DP的转移过程中强制一定要更新到dp[maxPos][k]这个状态，那么最终dp[maxPos][k]所存储的就是最终答案。
