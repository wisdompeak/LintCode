### 967. Quality Inspection

#### Description
```
有一个进货商，到工厂里挑选一批商品，工厂中一共提供了 n 件商品。
他会给这些商品打分，商品会被区分为优秀和良好两种品质，如果第 i 个商品是优秀的，它就会被打分为 a_i​，否则被打分为 b_i。
进货商会将这些商品中 分数 大于等于 (最大分数 * p%) 的商品认定为有价值的，并且买走它们。
请问这个进货商最多有可能买走多少件商品。

每个商品之间没有关联，都有可能被认定为优秀的。
一共有 n 样商品，1≤n≤10^5
p% 满足1≤p≤100。
分数数组 a,b 满足 1≤bi ≤ai ≤10^7 。
```
##### 分析：
```
n件商品对应着n种质量，这n种质量有着固定的2n种候选。我们将这2n种分数放在一个数组prices里，从小到大排序。
a b a b a a ....  a b b  a 
          ^              ^
        p%*M1< --------- M1
假设我们认为这些商品里的最大分数就是prices里的最大值M1，
那么我们只需要将一个指针从末尾不停地左移，划过所有分数在[p%*M,M1]区间的商品，数一数有多少件即可。
注意，如果某件商品的a和b都在这个区间里，那么我们只能算作一件。

a b a b a a ....  a b b  a 
    ^                 ^
   p%*M2 < --------- M2
接下来，如果我们认为这些商品里的最大分数是候选里的第二大值M2, 那么新的查验区间就是[p%*M2,M2]。
这个新区间相比于之前的区间，右边界左移了一位，左边界向左移了若干位。
我们在考察这个新区间时，不需要重新数对应了多少件商品，
只需要考虑 (1) 新加入的分数对应着多少新加入的商品 (2) 移出区间的分数（也就是M1）对应着多少被移出的商品。

那么这个如何判断呢？
我们要设置一个visited数组，visited[i]表示第i件商品被计入了这个区间。
(1) 对于任何新加入的分数，我们看一下它对应的商品是否已经标记visited：不是的话count+=1，否则count不增加。
(2) 对于移出区间的分数，情况更复杂一些：我们需要看这个分数是这个商品的a分数还是b分数。
	(a) 如果移出的是b分数，显然这个区间不会再包含该商品的a分数。故visited可以置零，count-=1。
	(b) 如果移出的是a分数，这个区间可能会包含该商品的b分数（即p%*M<=b<=M）。
		只有排除这种情况后，visited可以置零，count-=1; 否则visited和count都不变化。

另外，本题还需要注意的是：并非所有的分数都可以用来作为最大值M。当第一次尝试某一个b分数作为最大值M后，就可以停止程序。
这是因为如果M再小的话，必然会小于某一个商品的分数（无论是a还是b）。但这与M是所有商品的最大分数相矛盾。
  ...  b a  a 

所以本题算法的时间复杂度是O(2Nlog2N). 排序O(2Nlog2N)之后是一个双指针O(2N).

思考题：如果选取的商品要求最小值不低于最大值的p%，问最多能买走多少件商品？
```
